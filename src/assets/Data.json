{
  "lec1": [
    {
      "title": "أنواع البيانات في بايثون",
      "subtitle": "فهم الأنواع المختلفة للبيانات",
      "explanation": "\nفي لغة بايثون، فيه أنواع بيانات جاهزة ممكن تستخدمها مباشرة بدون ما تعرّفها أو تعمل إعدادات خاصة. كل نوع ليه طريقة استخدامه ومجموعة العمليات اللي ينفع تطبقها عليه. أشهر أنواع البيانات اللي هتقابلها:\n\n1. **الأرقام (Numbers)**: تشمل الأعداد الصحيحة (int) مثل 10 أو -5، وأعداد الكسور العشرية (float) مثل 3.14 أو -0.5.\n2. **النصوص (Strings)**: وهي عبارة عن مجموعة من الحروف أو الكلمات أو الجُمل، وتكون بين علامات تنصيص مفردة أو مزدوجة.\n3. **القيمة المنطقية (Boolean)**: القيمتين `True` أو `False` وتُستخدم للتعبير عن الحالات الشرطية.\n4. **التجميعات (Collections)**: مثل القوائم (list) اللي بتخزن أكتر من عنصر بترتيب، أو القواميس (dict) اللي بتخزن بيانات على شكل (مفتاح: قيمة).\n\nممكن تعرف نوع أي قيمة أو متغير باستخدام الدالة المدمجة `type()`، وهي مفيدة جدًا لمعرفة البيانات أثناء اختبار أو تصحيح الكود.",
      "code": "\n# أرقام\ninteger = 42\nfloat_num = 3.14\n\n# نصوص\ntext = \"Hello World\"\nchar = 'A'\n\n# قيمة منطقية\nis_true = True\nis_false = False\n\n# تجميعات\nmy_list = [1, 2, 3]\nmy_dict = {\"key\": \"value\"}\n\n# معرفة نوع البيانات\nprint(type(42))        # <class 'int'>\nprint(type(3.14))      # <class 'float'>\nprint(type(\"Hello\"))   # <class 'str'>",
      "output": "\n<class 'int'>\n<class 'float'>\n<class 'str'>",
      "notes": "\n- لغة بايثون بتحدد نوع البيانات تلقائيًا بناءً على القيمة اللي كتبتها.\n- استخدام `type()` بيساعدك تعرف نوع المتغير لو كنت مش متأكد.\n- معرفة نوع البيانات مهمة علشان تختار العمليات اللي ينفع تطبقها على المتغير.\n",
      "question": {
        "text": "ما نوع البيانات في السطر التالي؟\n\nx = [1, 2, 3]",
        "options": ["int", "list", "float", "string"],
        "correct": "list",
        "explanation": "الأقواس المربعة [ ] في بايثون بتعني إن القيمة من النوع list (قائمة)."
      }
    },
    {
      "title": "المتغيرات في بايثون",
      "subtitle": "إزاي نخزن وندير البيانات",
      "explanation": "\nالمتغيرات (Variables) هي أماكن بنخزن فيها البيانات علشان نقدر نستخدمها أو نعدل عليها لاحقًا. تقدر تعتبر المتغير كصندوق عليه اسم، بتحط جواه قيمة.\nفي بايثون، مش محتاج تحدد نوع البيانات وقت إنشاء المتغير، لأن بايثون بتحدد النوع تلقائي من القيمة اللي كتبتها. وده بيسهّل عليك الكتابة مقارنة بلغات تانية بتحتاج تحدد النوع يدوي.",
      "code": "\n# إنشاء متغيرات\nname = \"Alice\"      # نص (String)\nage = 25            # عدد صحيح (Integer)\nheight = 5.6        # عدد عشري (Float)\nis_student = True   # قيمة منطقية (Boolean)\n\n# تغيير قيم المتغيرات\nage = 26\nname = \"Bob\"",
      "output": "\n(الكود هنا بيخزن القيم فقط، مفيش ناتج مباشر إلا لو استخدمنا print.)",
      "notes": "\n- الحروف الكبيرة والصغيرة بتفرق في أسماء المتغيرات: `Age` غير `age`.\n- اسم المتغير لازم يبدأ بحرف أو بـ _ (underscore)، ومينفعش يبدأ برقم.\n- مينفعش تستخدم كلمات محجوزة زي if، for، class كأسماء متغيرات.\n",
      "question": {
        "type": "multiple",
        "text": "أي من التالي يُعتبر اسم متغير صحيح في بايثون؟",
        "options": ["1name", "name_1", "for", "is student"],
        "correct": "name_1",
        "explanation": "`1name` غلط لأنه بيبدأ برقم – و`for` كلمة محجوزة – و`is student` فيه مسافة."
      }
    },
    {
      "title": "دالة الطباعة print()",
      "subtitle": "إزاي تطبع نتايج على الشاشة",
      "explanation": "\nدالة `print()` هي واحدة من أهم الأدوات في بايثون، وبتستخدم لطباعة النصوص أو القيم على الشاشة علشان تشوف النتيجة أو تتأكد إن الكود شغال صح.\nممكن تستخدمها لطباعة نصوص ثابتة، أو القيم اللي مخزنة في متغيرات، أو حتى عمليات حسابية مباشرة.",
      "code": "\n# طباعة نصوص مباشرة\nprint(\"Hello, World!\")\nprint(42)\nprint(3.14)\n\n# طباعة متغيرات\nname = \"Alice\"\nage = 25\nprint(name)\nprint(\"My name is\", name)\nprint(\"I am\", age, \"years old\")",
      "output": "\nHello, World!\n42\n3.14\nAlice\nMy name is Alice\nI am 25 years old",
      "notes": "\n- ممكن تطبع أكتر من قيمة في نفس السطر باستخدام الفواصل.\n- `print()` بتحط مسافة تلقائي بين القيم لما تستخدم فواصل.\n- لو عايز تطبع نصوص مع متغيرات بدون دمج يدوي، ممكن تستخدم أساليب التنسيق القديمة زي `%` أو `.format()` بدل الـ f-string.\n",
      "question": {
        "text": "ما ناتج السطر التالي؟\n\nname = \"Ali\"\nprint(\"Hello\", name)",
        "options": ["Hello name", "Hello Ali", "Ali", "Error"],
        "correct": "Hello Ali",
        "explanation": "لأن `print()` هنا بتطبع الكلمة Hello وبعدها قيمة المتغير name وهي Ali."
      }
    },
    {
      "title": "دالة الإدخال input()",
      "subtitle": "إزاي تاخد بيانات من المستخدم",
      "explanation": "\nدالة `input()` بتخلي البرنامج يوقف التنفيذ مؤقتًا علشان ينتظر إن المستخدم يكتب حاجة في الكيبورد، وبعدين بترجع اللي المستخدم كتبه كنص (String) حتى لو كتب أرقام.\nده معناه إنك لو محتاج الرقم كعدد صحيح أو عشري، لازم تحوله بنفسك باستخدام دوال التحويل زي `int()` أو `float()`.\nده مفيد جدًا لو بتعمل برامج تفاعلية، زي الآلات الحاسبة أو تسجيل بيانات.\n",
      "code": "\n# ناخد إدخال نصي من المستخدم\nname = input(\"What's your name? \")\nprint(\"Hello,\", name)\n\n# ناخد إدخال رقمي من المستخدم\nage_str = input(\"How old are you? \")\nage = int(age_str) # تحويل النص إلى عدد صحيح\nprint(\"Next year you'll be\", age + 1)\n\n# تحويل مباشر لعدد عشري\nheight = float(input(\"Your height in meters: \"))\nprint(\"You are\", height, \"meters tall\")",
      "output": "\nWhat's your name? Alice\nHello, Alice\nHow old are you? 25\nNext year you'll be 26\nYour height in meters: 1.65\nYou are 1.65 meters tall",
      "notes": "\n- `input()` دايمًا بترجع نص (String) حتى لو المستخدم كتب أرقام.\n- لازم تستخدم `int()` أو `float()` لو عايز تحول الإدخال لرقم.\n- الأفضل تتحقق من إن الإدخال صحيح قبل التحويل علشان تتجنب الأخطاء.\n",
      "question": {
        "text": "ما نوع البيانات الناتجة من السطر التالي؟\n\nx = input(\"Enter something: \")",
        "options": ["int", "float", "string", "boolean"],
        "correct": "string",
        "explanation": "دالة `input()` دائمًا بترجع نص (String) حتى لو الإدخال كان رقم."
      }
    },
    {
      "title": "دالة len()",
      "subtitle": "اعرف طول العناصر",
      "explanation": "\nدالة `len()` هي دالة مدمجة في بايثون بترجع عدد العناصر داخل كائن زي النصوص، القوائم، أو القواميس.\nفي النصوص، `len()` بترجع عدد الحروف بما فيها المسافات.\nفي القوائم، بترجع عدد العناصر.\nفي القواميس، بترجع عدد الأزواج (مفتاح + قيمة).\n",
      "code": "\n# طول النصوص\nname = \"Alice\"\nprint(len(name)) # الناتج: 5\n\n# طول القوائم\nnumbers = [1, 2, 3, 4, 5]\nprint(len(numbers)) # الناتج: 5\n\n# طول القواميس\nperson = {\"name\": \"Alice\", \"age\": 25}\nprint(len(person)) # الناتج: 2\n\n# عناصر فاضية\nempty_string = \"\"\nempty_list = []\nprint(len(empty_string)) # 0\nprint(len(empty_list))   # 0",
      "output": "\n5\n5\n2\n0\n0",
      "notes": "\n- `len()` مفيدة لمعرفة طول البيانات أو التأكد إذا كانت فارغة.\n- في النصوص، بيتم حساب كل الحروف بما فيها المسافات.\n- في القواميس، بيتم حساب عدد المفاتيح.\n",
      "question": {
        "text": "ما ناتج الكود التالي؟\n\nprint(len([\"a\", \"b\", \"c\"]))",
        "options": ["2", "3", "1", "0"],
        "correct": "3",
        "explanation": "القائمة فيها 3 عناصر، فالدالة `len()` بترجع 3."
      }
    },
    {
      "title": "الكومنتات (التعليقات)",
      "subtitle": "علّق على الكود بتاعك",
      "explanation": "\nالتعليقات (Comments) هي نصوص بيكتبها المبرمج داخل الكود علشان تشرح أو توضح وظيفة جزء معين.\nالمترجم بيتجاهل التعليقات وقت تشغيل البرنامج، وده معناه إنها مش بتأثر على الأداء أو النتيجة.\nالتعليقات بتساعدك ترجع للكود بعد فترة وتفهمه بسرعة، وكمان بتفيد أي حد بيقرأ الكود بعدك.\n",
      "code": "\n# تعليق في سطر واحد\nname = \"Alice\"  # تعليق في نهاية السطر\n\n# كتابة عدة تعليقات متتالية\n# كل سطر يبدأ بـ #\nage = 25\n\n\"\"\"\nتعليق متعدد الأسطر\nباستخدام ثلاث علامات تنصيص\nمفيد لشرح أجزاء كبيرة من الكود\n\"\"\"\n\n# TODO: إضافة التحقق من صحة البيانات لاحقًا\nresult = age * 2",
      "output": "",
      "notes": "\n✅ استخدم التعليقات لـ:\n- شرح سبب كتابة الكود.\n- توضيح الأجزاء المعقدة.\n- التنويه للمهام الناقصة.\n\n❌ تجنب:\n- كتابة تعليقات واضحة جدًا بلا داع.\n- ترك تعليقات قديمة ومضللة.\n- استخدام التعليقات بدل تحسين الكود نفسه.\n",
      "question": {
        "text": "ما الفائدة الرئيسية من استخدام التعليقات في الكود؟",
        "options": [
          "زيادة سرعة تنفيذ الكود",
          "جعل الكود غير قابل للقراءة",
          "شرح الكود وتوضيح المنطق",
          "تشغيل أوامر خاصة بالمترجم"
        ],
        "correct": "شرح الكود وتوضيح المنطق",
        "explanation": "التعليقات بتساعد المبرمجين يفهموا الغرض من الكود وخطواته."
      }
    },
    {
      "title": "محرف السطر الجديد (\\n)",
      "subtitle": "إنشاء فواصل بين السطور في النصوص",
      "explanation": "\nمحرف السطر الجديد `\\n` بيستخدم علشان يعمل كسر سطر، يعني أي نص بعده يطلع في سطر جديد.\nده بيكون مفيد في ترتيب الإخراج أو عرض البيانات على شكل منظم.\n",
      "code": "\n# استخدام \\n داخل النصوص\nprint(\"Hello\\nWorld\")\n\n# أكثر من سطر جديد\nprint(\"Line 1\\nLine 2\\nLine 3\")\n\n# مثال عملي\nmessage = \"Name: Alice\\nAge: 25\\nCity: New York\"\nprint(message)",
      "output": "\nHello\nWorld\nLine 1\nLine 2\nLine 3\nName: Alice\nAge: 25\nCity: New York",
      "notes": "\n- `\\n` بيعمل سطر جديد.\n- ممكن تستخدم ثلاث علامات تنصيص `\"\"\"` لكتابة نصوص متعددة الأسطر.\n- فيه محارف خاصة تانية زي `\\t` للمسافة البادئة، و`\\\\` للشرطة المائلة.\n",
      "question": {
        "text": "ما تأثير \\n في النص التالي؟\n\nprint(\"Hello\\nWorld\")",
        "options": [
          "يطبع HelloWorld في سطر واحد",
          "يطبع Hello وWorld في سطرين",
          "يطبع Hello\\nWorld حرفيًا",
          "ينتج خطأ"
        ],
        "correct": "يطبع Hello وWorld في سطرين",
        "explanation": "`\\n` بيكسر السطر، فالنص بيظهر في سطرين."
      }
    },
    {
      "title": "ملخص بايثون",
      "subtitle": "تجميع كل اللي اتعلمناه في برنامج واحد",
      "explanation": "هنا هنكتب برنامج بايثون كامل نستخدم فيه كل المفاهيم اللي اتعلمناها لحد دلوقتي – من غير دوال.",
      "code": "print(\"Welcome to the Person Info Calculator!\\n\")\n\nname = input(\"Enter your name: \")\nbirth_year = int(input(\"Enter your birth year: \"))\n\ncurrent_year = 2024\nage = current_year - birth_year\nname_length = len(name)\n\nprint(\"\\n\" + \"=\"*30)\nprint(\"YOUR INFORMATION\")\nprint(\"=\"*30)\nprint(\"Name:\", name)\nprint(\"Age:\", age)\nprint(\"Name length:\", name_length, \"characters\")",
      "output": "Welcome to the Person Info Calculator!\n\nEnter your name: Ahmed\nEnter your birth year: 2000\n\n==============================\nYOUR INFORMATION\n==============================\nName: Ahmed\nAge: 24\nName length: 5 characters",
      "notes": "🎉 مفاهيم استخدمناها:\n✓ المتغيرات\n✓ أنواع البيانات\n✓ print()\n✓ input()\n✓ len()\n✓ \\n\n✓ العمليات الحسابية\n✓ تكرار الحروف في الطباعة",
      "question": {
        "text": "ما نوع البيانات التي تُخزن في المتغير \n\n name = input(\"Enter your name: \")\n ",
        "options": ["int", "string", "list", "bool"],
        "correct": "string",
        "explanation": "لأن قيمة name مأخوذة من input() وهي دايمًا نص (string)."
      }
    }
  ],
  "lec2": [
    {
      "title": "العمليات الحسابية في بايثون",
      "subtitle": "إزاي نستخدم الأرقام ونحسب بيها",
      "explanation": "العمليات الحسابية (Arithmetic Operators) بتسمحلك تنفذ حسابات على أرقام صحيحة أو عشرية. كل عملية لها رمز وسلوك معين، ولازم تلاحظ الفرق بين القسمة العادية والقسمة بدون باقي مع سلوك الأعداد السالبة.\n\nالرموز الأساسية:\n+  : جمع\n-  : طرح\n*  : ضرب\n/  : قسمة (always returns float)\n// : قسمة بدون كسور (floor division) — بترجع أقرب عدد صحيح أقل من أو يساوي الناتج (تأخذ الاتجاه نحو -∞ مع السالبة)\n%  : باقي القسمة (modulus)\n** : القوة (exponent)\n\nنقاط مهمة:\n- `/` دايمًا بيرجع float حتى لو الأعداد كانت صحيحة.\n- `//` مع أعداد سالبة بيعمل floor (مثال: -10 // 3 = -4).\n- `%` بيحافظ على العلاقة: (a // b) * b + (a % b) == a.\n- `**` أعلى أسبقية من الضرب، وهو right-associative (شوف الأمثلة).",
      "code": "\na = 10\nb = 3\n\nprint(a + b)   # جمع => 13\nprint(a - b)   # طرح => 7\nprint(a * b)   # ضرب => 30\nprint(a / b)   # قسمة عادية => 3.3333333333333335 (float)\nprint(a // b)  # قسمة بدون كسور => 3\nprint(a % b)   # باقي القسمة => 1\nprint(a ** b)  # 10 أس 3 => 1000\n\n# أمثلة تبين سلوك القسمة والباقي مع أعداد سالبة\nc = -10\nd = 3\nprint(c // d)  # -10 // 3 => -4 (floor towards -inf)\nprint(c % d)   # -10 % 3 => 2  (لأن -4*3 + 2 = -10)\n",
      "output": "\n13\n7\n30\n3.3333333333333335\n3\n1\n1000\n-4\n2\n",
      "notes": "\n- القسمة `/` دايمًا بتدي ناتج عشري (float).\n- `//` بيقدِّم قسمة 'floor' مش تقريب؛ فـ -5 // 2 = -3 مش -2.\n- `%` مفيد لمعرفة الباقي، والتحقق من فردية/زوجية الرقم: `if x % 2 == 0:` -> زوجي.\n- انتبه لنتائج الـ `**` لأنها ممكن تكبر قوي لو الأس كبير (استهلاك ذاكرة/وقت).\n",
      "question": {
        "type": "multiple",
        "text": "ما نتيجة 2 ** 3 في بايثون؟",
        "options": ["6", "8", "9", "5"],
        "correct": "8",
        "explanation": "لأن 2 ** 3 معناها 2 مرفوع للقوة 3 = 2 × 2 × 2 = 8."
      }
    },
    {
      "title": "عمليات الإسناد",
      "subtitle": "إزاي ندي قيمة لمتغير ونتحكم فيها",
      "explanation": "عمليات الإسناد بتخزن قيمة في متغير. أبسطها `=`، وفيه أشكال مختصرة بتعمل العملية وتخزن النتيجة في نفس المتغير (augmented assignment). دي مفيدة لتقصير الكود وللتعبير بوضوح عن التغير في المتغير.\n\nأمثلة على operators المركبة: `=+`, `=-`, `=*`, `=/`, `=//`, `=%`, `=**`.\nملاحظة: `x /= y` دايمًا هيحوّل الناتج لـ float إذا ماكانش بالفعل float.",
      "code": "\nx = 10\nprint(x)   # 10\nx += 5     # نفس x = x + 5 => 15\nprint(x)   # 15\nx -= 3     # نفس x = x - 3 => 12\nprint(x)   # 12\nx *= 2     # نفس x = x * 2 => 24\nprint(x)   # 24\nx /= 4     # نفس x = x / 4 => 6.0 (float)\nprint(x)   # 6.0\n\n# المزايا: تقدر تستخدمها مع السلاسل والقوائم أيضاً\ns = \"Hello\"\ns += \" World\"   # concat => \"Hello World\"\nprint(s)\n",
      "output": "\n10\n15\n12\n24\n6.0\nHello World\n",
      "notes": "\n- العلامات المركبة بتخلي الكود أبسط وأسهل للقراءة.\n- تقدر تستخدمها مع النصوص والقوائم (مثال: list += [1,2]).\n- القسمة بالـ `/=` بتحول الناتج لـ float دائمًا.\n- خليك حذرًا مع القيم غير المتوافقة (مثلا محاولة `+=` بين عدد ونص هتسبب خطأ).",
      "question": {
        "type": "multiple",
        "text": "ما قيمة x بعد تنفيذ الكود التالي؟\n\nx = 4\nx *= 3",
        "options": ["7", "12", "1.33", "3"],
        "correct": "12",
        "explanation": "لأن x *= 3 معناها x = x * 3 => 4 × 3 = 12."
      }
    },
    {
      "title": "عمليات المقارنة",
      "subtitle": "إزاي نقارن بين القيم",
      "explanation": "عمليات المقارنة بترد قيم منطقية (`True` أو `False`). بنستخدمها في الشروط (`if`، `while`) أو لتحديد سلوك البرنامج بناءً على القيم.\n\nالرّموز الشائعة:\n==  : يساوي\n!=  : لا يساوي\n>   : أكبر من\n<   : أصغر من\n>=  : أكبر أو يساوي\n<=  : أصغر أو يساوي\n\nنقاط مهمة:\n- `==` يقارن القيم، مش الهوية. استخدام `is` بيقارن الهوية (هل المتغيران يشيران لنفس الكائن في الذاكرة؟).\n- تقدر تعمل chaining: `1 < x <= 10` — ده مفيد وصحيح في بايثون.\n- للموجودية في حاويات نستخدم `in`، مثلاً: `if 'a' in 'cat':`.",
      "code": "\na = 5\nb = 3\n\nprint(a == b)   # False\nprint(a != b)   # True\nprint(a > b)    # True\nprint(a < b)    # False\nprint(a >= 5)   # True\nprint(b <= 3)   # True\n\n# مثال على 'is' و 'in'\nlist1 = [1,2,3]\nlist2 = list1\nprint(list1 is list2)   # True لأنهم نفس الكائن\nprint(2 in list1)       # True\n",
      "output": "\nFalse\nTrue\nTrue\nFalse\nTrue\nTrue\nTrue\nTrue\n",
      "notes": "\n- `==` مقارنة للقيمة، `is` مقارنة للهوية.\n- المقارنات مفيدة داخل الشروط والتكرارات.\n- كن حذرًا عند مقارنة هياكل بيانات كبيرة أو حساسة للهوية (مثل الـ objects).",
      "question": {
        "type": "multiple",
        "text": "ما نتيجة `7 != 7`؟",
        "options": ["True", "False", "7", "None"],
        "correct": "False",
        "explanation": "لأن 7 تساوي 7، فـ `!=` (لا تساوي) هتكون False."
      }
    },
    {
      "title": "ترتيب العمليات الحسابية",
      "subtitle": "إيه اللي بيتحسب الأول؟",
      "explanation": "لما تكتب تعبير فيه أكتر من عملية، بايثون بتنفيذ العمليات حسب قواعد الأولوية (precendence) زي الرياضيات. لو عايز تغير الترتيب استخدم الأقواس `()` بوضوح.\n\nالأسبقيات الرئيسية (من الأعلى للأقل):\n1. () الأقواس\n2. ** الأس (exponent) — ودي right-associative (يعني 2 ** 3 ** 2 = 2 ** (3 ** 2))\n3. unary + و - (زي +x, -x)\n4. * و / و // و % (الضرب والقسمة والقسمة بدون كسور والباقي)\n5. + و - (الجمع والطرح)\n\nاستخدم الأقواس لو شككت في ترتيب التنفيذ.",
      "code": "\nresult = 2 + 3 * 4      # 3 * 4 = 12 + 2 = 14\nprint(result)\n\nresult = (2 + 3) * 4    # (2+3)=5 * 4 = 20\nprint(result)\n\n# توضيح لخاصية الأس right-associative\nprint(2 ** 3 ** 2)      # = 2 ** (3 ** 2) = 2 ** 9 = 512\n",
      "output": "\n14\n20\n512\n",
      "notes": "\n- دايمًا استخدم الأقواس لو مش واضح أو لو عايز نتيجة مختلفة عن ترتيب الافتراضي.\n- الانتباه لخاصية الأس مهمة لأنها ممكن تعطي نتائج كبيرة جداً.",
      "question": {
        "type": "multiple",
        "text": "ما نتيجة `2 + 5 * 2`؟",
        "options": ["14", "20", "12", "10"],
        "correct": "12",
        "explanation": "لأن الضرب بيتنفذ الأول: 5 * 2 = 10 ثم + 2 = 12."
      }
    },
    {
      "title": "تحويل نوع البيانات",
      "subtitle": "إزاي نحول بين الأنواع المختلفة",
      "explanation": "في بايثون بنحتاج نحول القيم لأنواع مختلفة: من نص لرقم، من عدد صحيح لعشري، أو لنص علشان نطبعه.\nالدوال الشائعة للتحويل:\n- `int()`  : تحويل لـ عدد صحيح (يقطع الكسور، يقرب نحو الصفر)\n- `float()`: تحويل لـ عدد عشري\n- `str()`  : تحويل لنص\n- `bool()` : تحويل لقيمة منطقية (`False` للقيم الفارغة مثل 0، \"\"، []، None)\n\nنقطة مهمة: تحويل نص غير رقمي لـ int أو float بيرمي `ValueError` — استخدم try/except أو تحقق من النص قبل التحويل.",
      "code": "\nx = \"5\"\ny = int(x)    # تحويل النص \"5\" لعدد صحيح\nprint(y + 2)   # 5 + 2 = 7\n\nz = str(10)    # تحويل الرقم لنص\nprint(z + \"0\")  # \"10\" + \"0\" => \"100\"\n\n# تحويل نص عشري\ns = \"3.14\"\nf = float(s)\nprint(f + 0.86)  # 3.14 + 0.86 = 4.0\n\n# محاولة تحويل غير صالحة يجب التعامل معها\ntry:\n    bad = int(\"hello\")\nexcept ValueError:\n    print(\"خطأ: لا يمكن تحويل 'hello' إلى int\")\n\n# تحويل عدد سالب عشري إلى int يقطع الكسور نحو الصفر\nprint(int(-3.7))  # => -3\n",
      "output": "\n7\n100\n4.0\nخطأ: لا يمكن تحويل 'hello' إلى int\n-3\n",
      "notes": "\n- لازم تتأكد إن النص ممكن يتحول لرقم (مثال: \"5\" أو \"3.14\").\n- `int()` على نص عشري مثل \"3.14\" يدي خطأ — لازم تحول الأول لـ float ثم لـ int لو محتاج.\n- `bool(0)` => False، `bool(\"\")` => False، `bool(\"0\")` => True لأن النص غير فارغ.\n",
      "question": {
        "type": "multiple",
        "text": "ما ناتج الكود؟\n\nx = \"7\"\nprint(int(x) + 3)",
        "options": ["10", "73", "خطأ", "7"],
        "correct": "10",
        "explanation": "\"7\" اتحولت لـ int = 7 + 3 = 10"
      }
    },
    {
      "title": "استخدام f-string",
      "subtitle": "طريقة ذكية لكتابة النصوص مع المتغيرات",
      "explanation": "f-strings طريقة حديثة وسهلة لدمج المتغيرات داخل النص. بتبدأ بـ حرف `f` قبل النص، والعبارات اللي جوه `{}` بتتقرَّأ وتُستبدل بالقيمة في وقت التنفيذ.\n\nمزايا:\n- أوضح واقصر من concatenation.\n- تقدر تحط تعابير مباشرة داخل `{}`، وتستخدم تنسيقات مثل `.2f` للأرقام.\n- متاحة من Python 3.6 فصاعدًا.",
      "code": "\nname = \"Ali\"\nage = 20\n\nprint(f\"اسمي {name} وسني {age} سنة\")\nprint(f\"2 + 3 = {2 + 3}\")\npi = 3.14159\nprint(f\"Pi تقريباً {pi:.2f}\")   # تنسيق لعرض رقم بعشرتين بعد الفاصلة\n",
      "output": "\nاسمي Ali وسني 20 سنة\n2 + 3 = 5\nPi تقريباً 3.14\n",
      "notes": "\n- تقدر تعمل تعابير داخل الأقواس: `f\"{x * 2}\"` أو `f\"{func(5)}\"`.\n- للتنسيق استخدم الصيغة `:{format_spec}`، مثال: `{value:.2f}`.\n- لو عايز تستخدم قوسين معقوفين حرفيًا اكتب `{{` أو `}}` داخل النص.",
      "question": {
        "type": "multiple",
        "text": "ما نتيجة الكود؟\n\nx = 5\ny = 10\nprint(f\"{x} + {y} = {x + y}\")",
        "options": ["5 + 10 = 15", "x + y = 15", "15", "خطأ"],
        "correct": "5 + 10 = 15",
        "explanation": "f-string بيطبع القيم: x = 5 و y = 10 => 5 + 10 = 15"
      }
    },
    {
      "title": "أداة العمليات الحسابية المصغّرة",
      "subtitle": "برنامج يجري كل العمليات الحسابية على رقمين",
      "explanation": "الأداة تاخد رقمين من المستخدم وتطبع ناتج العمليات الأساسية. مهم تتحقق من صحة المدخلات وتتجنب القسمة على صفر.\n\nالنقاط التحسينية في النسخة دي:\n- التعامل مع الأخطاء (غير رقم أو قسمة على صفر)\n- استخدام `float()` لتحويل المدخلات لقبول الأعداد العشرية\n- تنسيق النتائج باستخدام f-strings",
      "code": "print(\"Welcome to the Mini Math Tool!\")\n\ntry:\n    num1 = float(input(\"Enter the first number: \"))\n    num2 = float(input(\"Enter the second number: \"))\nexcept ValueError:\n    print(\"خطأ: من فضلك ادخل أرقام صحيحة.\")\nelse:\n    print(f\"\\nAddition: {num1} + {num2} = {num1 + num2}\")\n    print(f\"Subtraction: {num1} - {num2} = {num1 - num2}\")\n    print(f\"Multiplication: {num1} * {num2} = {num1 * num2}\")\n\n    if num2 == 0:\n        print(\"Division: undefined (division by zero)\")\n        print(\"Floor Division: undefined (division by zero)\")\n        print(\"Remainder: undefined (division by zero)\")\n    else:\n        print(f\"Division: {num1} / {num2} = {num1 / num2}\")\n        print(f\"Floor Division: {num1} // {num2} = {num1 // num2}\")\n        print(f\"Remainder: {num1} % {num2} = {num1 % num2}\")\n\n    # احذر من رفع رقم لقوة كبيرة لأنها ممكن تستهلك ذاكرة/وقت كبير\n    try:\n        print(f\"Power: {num1} ** {num2} = {num1 ** num2}\")\n    except OverflowError:\n        print(\"Power: الناتج كبير جداً (Overflow)\")\n",
      "output": "Welcome to the Mini Math Tool!\nEnter the first number: 10\nEnter the second number: 5\n\nAddition: 10.0 + 5.0 = 15.0\nSubtraction: 10.0 - 5.0 = 5.0\nMultiplication: 10.0 * 5.0 = 50.0\nDivision: 10.0 / 5.0 = 2.0\nFloor Division: 10.0 // 5.0 = 2.0\nRemainder: 10.0 % 5.0 = 0.0\nPower: 10.0 ** 5.0 = 100000.0",
      "notes": "- استخدمنا `float()` لتحويل إدخال المستخدم لأرقام عشرية.\n- تحقّقنا من القسمة على صفر لتجنب `ZeroDivisionError`.\n- حذرنا من عمليات `**` الكبيرة لأنها ممكن تسبب بطء أو overflow.\n- ممكن نطوّر الأداة لاحقًا لتدعم عمليات متتالية أو قائمة بالأرقام.",
      "question": {
        "text": "ما نتيجة العملية التالية عند إدخال الرقمين 7 و 2؟\n\nprint(f\"Power: {num1} ** {num2} = {num1 ** num2}\")",
        "options": ["14", "49", "128", "7"],
        "correct": "49",
        "explanation": "لأن num1 = 7 و num2 = 2، فـ num1 ** num2 = 7 ** 2 = 49."
      }
    }
  ],
  "lec3": [
    {
      "title": "مقدمة عن if statement",
      "subtitle": "إزاي نتحكم في مسار الكود بناءً على شرط",
      "explanation": "\nجملة if هي من أدوات التحكم في تدفق البرنامج (Flow Control Statements)، وبتخلينا نتحكم في الكود اللي يتنفذ بناءً على تحقق أو عدم تحقق شرط معين.\n\n📌 الفكرة ببساطة:\n- الشرط في if لازم يكون تعبير بيرجع True أو False.\n- لو الشرط True → الكود اللي جوه if يتنفذ.\n- لو الشرط False → الكود يتخطى.\n\n⚙️ الصيغة العامة:\n```\nif الشرط:\n    كود يتنفذ لو الشرط True\n```\n\n📝 مثال بسيط:\nفي المثال التالي، بنتحقق إذا كانت قيمة x أكبر من 3.\n",
      "code": "x = 5\nif x > 3:\n    print(\"x is greater than 3\")",
      "output": "x is greater than 3\n",
      "notes": "\n- لازم بعد if تحط شرط متكامل ينتهي بـ نقطتين `:`.\n- الكود اللي بعد if لازم يكون بمسافة بادئة (Indentation) 4 مسافات أو Tab.\n- ممكن يكون الشرط مقارنة أو حتى قيمة مباشرة.\n- بايثون حساس جدًا للمسافات البادئة، أي خطأ في الـ Indentation يسبب Error.",
      "question": {
        "type": "multiple",
        "text": "ماذا يحدث إذا كان الشرط False؟",
        "options": ["ينفذ الكود", "يُطبع خطأ", "يتجاهل الكود", "يكرر نفسه"],
        "correct": "يتجاهل الكود",
        "explanation": "لو الشرط False، بايثون بيتخطى الكود اللي تحت if بدون تنفيذ."
      }
    },
    {
      "title": "elif و else",
      "subtitle": "التفرع بين عدة حالات",
      "explanation": "\nفي بعض الأحيان، الشرط ما بيكونش حالة واحدة بس، وده بيخليك تحتاج أكتر من خيار:\n- elif: لو الشرط الأول ما تحققش، يجرب الشرط التاني.\n- else: بيتنفذ لو كل الشروط السابقة كانت False.\n\n⚙️ الصيغة:\n```\nif شرط1:\n    كود1\nelif شرط2:\n    كود2\nelse:\n    كود افتراضي\n```\n\n📌 ملحوظة:\n- تقدر تستخدم عدد غير محدود من elif.\n- else مش لازم، لكن لو موجود بيتنفذ لما كل الشروط تفشل.\n",
      "code": "x = 10\nif x < 5:\n    print(\"Less than 5\")\nelif x == 10:\n    print(\"Equal to 10\")\nelse:\n    print(\"Greater than 5 but not 10\")",
      "output": "Equal to 10\n",
      "notes": "\n- ترتيب الشروط مهم، أول شرط يتحقق هو اللي هيتنفذ والباقي يتجاهل.\n- لو أكتر من شرط True، بايثون بينفذ أول واحد فقط.",
      "question": {
        "type": "multiple",
        "text": "كم مرة يمكن استخدام elif؟",
        "options": ["مرة واحدة", "مرتين", "عدد غير محدود", "ماينفعش نستخدمها"],
        "correct": "عدد غير محدود",
        "explanation": "ممكن تستخدم elif بعدد غير محدود حسب الحاجة."
      }
    },
    {
      "title": "المقارنات في الشرط",
      "subtitle": "علامات المقارنة اللي بنستخدمها في if",
      "explanation": "\nأي شرط لازم يرجع True أو False. أشهر علامات المقارنة في بايثون:\n\n- `==` : يساوي\n- `!=` : لا يساوي\n- `>` : أكبر من\n- `<` : أصغر من\n- `>=` : أكبر من أو يساوي\n- `<=` : أصغر من أو يساوي\n\n📌 الفرق المهم:\n- علامة `=` تستخدم للإسناد.\n- علامة `==` تستخدم للمقارنة.\n",
      "code": "x = 8\nif x != 5:\n    print(\"x is not equal to 5\")",
      "output": "x is not equal to 5\n",
      "notes": "\n- المقارنة دايمًا بترجع قيمة Boolean.\n- مهم تفرق بين `=` (إسناد) و `==` (مقارنة)، لأن الخلط بينهم يسبب SyntaxError.",
      "question": {
        "type": "multiple",
        "text": "أي من التالي صحيح؟\nلو x = 4، فإن x == 4 تكون:",
        "options": ["False", "Error", "True", "None"],
        "correct": "True",
        "explanation": "لأن x فعلاً تساوي 4، فالمقارنة بترجع True."
      }
    },
    {
      "title": "استخدام and و or",
      "subtitle": "شروط مركبة داخل if",
      "explanation": "\nممكن نربط أكتر من شرط داخل if:\n- `and` : لازم الشرطين يكونوا True.\n- `or` : يكفي شرط واحد يكون True.\n- `not` : لعكس النتيجة.\n\n📌 ترتيب التنفيذ (الأولوية):\n1. `not`\n2. `and`\n3. `or`\n",
      "code": "x = 7\ny = 3\nif x > 5 and y < 5:\n    print(\"Both conditions are True\")",
      "output": "Both conditions are True\n",
      "notes": "\n- الأفضل استخدام أقواس () لو الشرط طويل.\n- استخدام and مع or بدون أقواس ممكن يسبب نتائج غير متوقعة بسبب أولوية التنفيذ.",
      "question": {
        "type": "multiple",
        "text": "متى تكون الجملة التالية True؟\n(x > 5 or x == 5)",
        "options": [
          "إذا x أقل من 5",
          "إذا x أكبر من أو يساوي 5",
          "دايمًا False",
          "مستحيل تتنفذ"
        ],
        "correct": "إذا x أكبر من أو يساوي 5",
        "explanation": "لأن or يكفي يتحقق شرط واحد."
      }
    },
    {
      "title": "القيم Truthy و Falsy في if",
      "subtitle": "إزاي بايثون بتفهم الشرط حتى بدون مقارنة",
      "explanation": "\nفي بايثون، ممكن تحط أي قيمة مكان الشرط، واللغة هتعتبرها True أو False حسب النوع والمحتوى.\n\n📌 القيم Falsy:\n- None\n- False\n- 0، 0.0\n- '' (سلسلة فارغة)\n- []، {}، () (قوائم أو قواميس أو مجموعات فاضية)\n\nأي حاجة غير كده تعتبر Truthy.\n",
      "code": "name = \"\"\nif name:\n    print(\"Hello\")\nelse:\n    print(\"Name is empty\")",
      "output": "Name is empty\n",
      "notes": "\n- مفيد في التحقق من وجود بيانات بدون مقارنة صريحة.\n- مثال: `if items:` بيتحقق إذا القائمة فيها عناصر.",
      "question": {
        "type": "multiple",
        "text": "ما نتيجة الكود التالي؟\nx = []\nif x:\n    print(\"فيه عناصر\")\nelse:\n    print(\"فاضي\")",
        "options": ["فيه عناصر", "فاضي", "Error", "مافيش مخرجات"],
        "correct": "فاضي",
        "explanation": "القائمة الفارغة تعتبر Falsy."
      }
    },
    {
      "title": "استخدام if مع input",
      "subtitle": "التفاعل مع المستخدم والتحقق من الإدخال",
      "explanation": "\nدالة input بتسمح بأخذ إدخال من المستخدم. القيمة اللي بترجعها بتكون String دائمًا.\nلو عايز تتعامل مع أرقام، لازم تحولها باستخدام int() أو float().\n",
      "code": "name = input(\"Enter your name: \")\nif name == \"Ahmed\":\n    print(\"Hello Ahmed!\")\nelse:\n    print(\"Welcome!\")",
      "output": "(يعتمد على إدخال المستخدم)",
      "notes": "\n- لازم تعرف أن input بترجع String حتى لو المستخدم كتب رقم.\n- الأفضل تتحقق من القيم بعد تحويل النوع المناسب.",
      "question": {
        "type": "multiple",
        "text": "ما نوع القيمة الراجعة من input()؟",
        "options": ["int", "bool", "str", "float"],
        "correct": "str",
        "explanation": "input بترجع نص (string)."
      }
    },
    {
      "title": "if متداخلة (Nested if)",
      "subtitle": "إزاي نحط شرط داخل شرط",
      "explanation": "\nممكن نكتب if داخل if لما يكون القرار التاني بيعتمد على نتيجة الأول.\nده مفيد لو عندك مستويات من التحقق.\n",
      "code": "x = 10\nif x > 5:\n    if x < 20:\n        print(\"x is between 5 and 20\")",
      "output": "x is between 5 and 20\n",
      "notes": "\n- كل مستوى if لازم يكون بمسافة بادئة إضافية.\n- كثرة التداخل ممكن تخلي الكود صعب القراءة، استخدم شروط مركبة كبديل لو أمكن.",
      "question": {
        "type": "multiple",
        "text": "هل هذا الكود صحيح؟\nif x > 0:\nprint(\"نعم\")",
        "options": ["نعم", "لا، بسبب التنسيق", "لا، شرط خطأ", "يحتاج else"],
        "correct": "لا، بسبب التنسيق",
        "explanation": "لازم يكون فيه مسافة بادئة تحت if (Indentation)."
      }
    },
    {
      "title": "التعبير الشرطي المختصر",
      "subtitle": "كتابة شرط بسيط في سطر واحد",
      "explanation": "\nالتعبير الشرطي المختصر (Ternary Operator) بيختصر جملة if-else في سطر واحد:\n```\nvalue_if_true if condition else value_if_false\n```\n",
      "code": "age = 16\nstatus = \"Adult\" if age >= 18 else \"Minor\"\nprint(status)",
      "output": "Minor\n",
      "notes": "\n- مناسب للحالات البسيطة.\n- تجنبه في الشروط المعقدة لأنه يقلل وضوح الكود.",
      "question": {
        "type": "multiple",
        "text": "ما نتيجة الكود التالي؟\nx = 5\nmsg = \"كبير\" if x > 10 else \"صغير\"\nprint(msg)",
        "options": ["كبير", "صغير", "خطأ", "مافيش مخرجات"],
        "correct": "صغير",
        "explanation": "لأن x مش أكبر من 10."
      }
    },
    {
      "title": "أهم دوال النصوص (string methods)",
      "subtitle": "التعامل مع النصوص في بايثون",
      "explanation": "\nالنصوص (Strings) في بايثون ليها دوال جاهزة لتعديلها أو البحث فيها أو تحليلها.\n\n📌 أشهر الدوال:\n1. lower() / upper()\n2. strip(), lstrip(), rstrip()\n3. replace()\n4. split()\n5. startswith() / endswith()\n6. find()\n7. count()\n8. isdigit(), isalpha(), isalnum()\n9. join()\n",
      "code": "# 1. lower() و upper()\nname = \"AhMeD\"\nprint(name.lower())\nprint(name.upper())\n\n# 2. strip() و lstrip() و rstrip()\ntxt = \"   Hello   \"\nprint(txt.strip())\nprint(txt.lstrip())\nprint(txt.rstrip())\n\n# 3. replace()\nmsg = \"hello world\"\nprint(msg.replace(\"world\", \"Python\"))\n\n# 4. split()\ntext = \"learn python now\"\nwords = text.split()\nprint(words)\n\n# 5. startswith() و endswith()\nfile = \"report.pdf\"\nprint(file.startswith(\"rep\"))\nprint(file.endswith(\".pdf\"))\n\n# 6. find()\nsentence = \"I love Python\"\nprint(sentence.find(\"Python\"))\nprint(sentence.find(\"Java\"))\n\n# 7. count()\ns = \"banana\"\nprint(s.count(\"a\"))\n\n# 8. isdigit(), isalpha(), isalnum()\nprint(\"123\".isdigit())\nprint(\"abc\".isalpha())\nprint(\"abc123\".isalnum())\n\n# 9. join()\nwords = [\"learn\", \"python\"]\nprint(\" \".join(words))",
      "output": "ahmed\nAHMED\nHello\nHello   \n   Hello\nhello Python\n['learn', 'python', 'now']\nTrue\nTrue\n7\n-1\n3\nTrue\nTrue\nTrue\nlearn python\n",
      "notes": "\n- معظم الدوال ما بتعدلش النص الأصلي، بترجع نسخة جديدة.\n- مفيدة جدًا في تنظيف البيانات أو معالجة النصوص.",
      "question": {
        "type": "multiple",
        "text": "أي من التالي يرجع قائمة (list)؟",
        "options": ["upper()", "replace()", "split()", "strip()"],
        "correct": "split()",
        "explanation": "split() بتقسّم النص لقائمة."
      }
    }
  ],
  "lec4": [
    {
      "title": "قائمة List في بايثون",
      "subtitle": "تخزين عدة قيم في متغير واحد",
      "explanation": "📌 الـ List هي نوع بيانات يسمح لك بتخزين عدة عناصر في متغير واحد.\n\nمواصفاتها:\n- العناصر مرتبة (Ordered).\n- يمكن تغييرها (Mutable).\n- يمكن أن تحتوي على أنواع مختلفة من البيانات.\n- يمكن تكرار العناصر فيها.\n\nتُنشأ القوائم باستخدام الأقواس المربعة `[]`.",
      "code": "fruits = ['تفاح', 'موز', 'برتقال']\nprint(fruits)\n\nmixed = [1, 'نص', True, 3.14]\nprint(mixed)",
      "output": "['تفاح', 'موز', 'برتقال']\n[1, 'نص', True, 3.14]",
      "notes": "- الـ List تسمح بالوصول للعناصر باستخدام الفهرس starting from 0.\n- يمكنك إنشاء قائمة فارغة باستخدام [].",
      "question": {
        "type": "multiple",
        "text": "هل يمكن أن تحتوي الـ List على أنواع بيانات مختلفة؟",
        "options": ["نعم", "لا"],
        "correct": "نعم",
        "explanation": "يمكن أن تحتوي الـ List على نصوص وأرقام وقيم منطقية معًا."
      }
    },
    {
      "title": "عمليات على الـ List",
      "subtitle": "إضافة، حذف، تعديل، والبحث في القوائم",
      "explanation": "📌 العمليات الأساسية على القوائم:\n\n1️⃣ **إضافة عناصر**:\n- append(item): يضيف عنصر في نهاية القائمة.\n- insert(index, item): يضيف عنصر في مكان معين.\n- extend(list2): يضيف عناصر قائمة أخرى.\n\n2️⃣ **حذف عناصر**:\n- remove(item): يحذف أول ظهور للعنصر.\n- pop(index): يحذف العنصر حسب الفهرس ويرجعه.\n- clear(): يحذف كل العناصر.\n\n3️⃣ **تعديل عناصر**:\n- يمكن تعديل عنصر معين بالفهرس مباشرة.\n\n4️⃣ **عمليات أخرى**:\n- sort(): ترتيب العناصر.\n- reverse(): عكس الترتيب.\n- index(item): إيجاد فهرس عنصر.\n- count(item): عدد مرات ظهور عنصر.",
      "code": "nums = [1, 2, 3]\nnums.append(4)\nnums.insert(1, 9)\nnums.extend([5, 6])\nprint(nums)\n\nnums.remove(9)\nnums.pop(0)\nprint(nums)\n\nnums[0] = 100\nprint(nums)",
      "output": "[1, 9, 2, 3, 4, 5, 6]\n[9, 2, 3, 4, 5, 6]\n[100, 3, 4, 5, 6]",
      "notes": "- index يبدأ من 0.\n- لو استخدمت remove لعنصر غير موجود → خطأ.\n- sort يشتغل فقط إذا كانت العناصر قابلة للمقارنة.",
      "question": {
        "type": "multiple",
        "text": "ما الدالة التي تستخدم لإضافة عنصر في نهاية القائمة؟",
        "options": ["append()", "insert()", "extend()", "add()"],
        "correct": "append()",
        "explanation": "append تضيف عنصر واحد في نهاية القائمة، بينما extend تضيف عناصر متعددة."
      }
    },

    {
      "title": "الدوال split() و join()",
      "subtitle": "تفكيك النصوص وتركيبها زي المحترف",
      "explanation": "\n- split(): بتقسّم النص لقائمة . لو ماحددتش فاصل، بتقسّم على اساس المسافات بمعني انها بتعتبر المسافة هي الفاصل بتاعها.\n- split(sep, maxsplit): تقدر تحدد الفاصل وعدد أقصى للتقسيم.\n- join(): بتجمع قائمة في نص واحد بفاصل تختاره , بمعني ان شغلها عكس الsplit . لازم كل العناصر تكون Strings.\nأمثلة عملية: قراءة أسماء مفصولة بفواصل، أو إعادة تركيب الكلمات في جملة منسّقة.",
      "code": "\ntext = \"apple,banana,orange\"\nfruits = text.split(\",\")\nprint(fruits)                # ['apple', 'banana', 'orange']\n\nline = \"one   two\\tthree\"\nprint(line.split())          # ['one', 'two', 'three'] (بيتعامل مع المسافات المتعددة)\n\nprint(\"-\".join([\"I\", \"love\", \"Python\"]))  # I-love-Python\n\n# لو عندك أرقام.. حوّلها لنص ودي ان شاء الله هتاخدها قدام \nnums = [1, 2, 3]\nprint(\", \".join(map(str, nums)))  # 1, 2, 3\n\n# maxsplit مثال\nprint(\"a|b|c|d\".split(\"|\", 2))     # ['a', 'b', 'c|d']\n",
      "output": "\n['apple', 'banana', 'orange']\n['one', 'two', 'three']\nI-love-Python\n1, 2, 3\n['a', 'b', 'c|d']",
      "notes": "\n- join يشتغل على Iterable من النصوص فقط.\n- split() بدون وسيط يتجاهل تكرار المسافات والتاب.\n- للتنظيف: استخدم .strip() لإزالة مسافات/علامات ترقيم على الأطراف قبل split.\n",
      "question": {
        "type": "multiple",
        "text": "إزاي نحوّل ['learn', 'python', 'now'] لجملة فيها مسافة بين كل كلمة؟",
        "options": [
          "' '.split(['learn','python','now'])",
          "' '.join(['learn','python','now'])",
          "join(' ', ['learn','python','now'])",
          "['learn','python','now'].join(' ')"
        ],
        "correct": "' '.join(['learn','python','now'])",
        "explanation": "الدالة join بتتندَه على الفاصل، وبتاخد Iterable من النصوص."
      }
    },
    {
      "title": "الفرق بين Module و Library و Framework",
      "subtitle": "فهم مكونات وأدوات البرمجة في بايثون",
      "explanation": "📌 في البرمجة، خصوصًا في بايثون، فيه مصطلحات بنسمعها كتير زي Module و Library و Framework، وكل واحد له دور مختلف.\n\n1️⃣ **Module**:\n- عبارة عن ملف واحد فيه كود بايثون (دوال، متغيرات، Classes).\n- الهدف: إعادة استخدام الكود بدل ما نكتبه كل مرة.\n- مثال: ملف `math.py` فيه دوال للعمليات الرياضية.\n\n2️⃣ **Library**:\n- مجموعة من الـ Modules المتكاملة.\n- بتكون مكتبة جاهزة بتقدم لك حلول أو وظائف في مجال معين.\n- مثال: مكتبة `NumPy` فيها Modules كتير للتعامل مع الأرقام والمصفوفات.\n\n3️⃣ **Framework**:\n- بيكون أكبر وأشمل من الـ Library.\n- بيحدد لك هيكل (Structure) وطرق عمل المشروع.\n- مش بس بيديك أدوات، لكن كمان بيجبرك تشتغل بطريقة معينة.\n- مثال: إطار العمل `Django` لتطوير مواقع الويب.\n\n💡 الفرق الأساسي:\n- Module: ملف واحد.\n- Library: مجموعة ملفات (Modules) تستخدمها بحرية.\n- Framework: بيحدد لك أسلوب العمل بجانب الأدوات.",
      "code": "# مثال على Module\nimport math\nprint(math.sqrt(16))  # من module math\n\n# مثال على Library\nimport random  # جزء من مكتبة البايثون القياسية\nprint(random.randint(1, 10))\n\n# مثال على Framework (لازم مشروع كامل)\n# from django.http import HttpResponse",
      "output": "4.0\n5  # رقم عشوائي مثال",
      "notes": "- Module = ملف .py فيه أكواد.\n- Library = مجموعة Modules.\n- Framework = بيحدد الهيكل وطريقة العمل.\n- مش كل Library Framework، لكن كل Framework يحتوي على مكتبات وModules.",
      "question": {
        "type": "multiple",
        "text": "ما الفرق الأساسي بين Library و Framework؟",
        "options": [
          "Library تحدد لك طريقة العمل، Framework لا",
          "Framework تحدد لك طريقة العمل، Library لا",
          "الاثنين يحددوا طريقة العمل",
          "لا يوجد فرق"
        ],
        "correct": "Framework تحدد لك طريقة العمل، Library لا",
        "explanation": "المكتبة مجرد أدوات تستخدمها وقت ما تحب، أما الـ Framework فهو يفرض عليك هيكل وطريقة معينة للعمل."
      }
    },
    {
      "title": "استخدام random module",
      "subtitle": "توليد القيم العشوائية في بايثون",
      "explanation": "📌 الـ random module بيسمح لنا نعمل عمليات توليد أرقام أو اختيارات عشوائية.\n\nأشهر الدوال:\n- `random.randint(a, b)`: يرجع رقم صحيح عشوائي بين a و b شاملين.\n- `random.random()`: يرجع رقم عشري بين 0 و 1.\n- `random.choice(seq)`: يختار عنصر عشوائي من قائمة.\n- `random.shuffle(seq)`: يغير ترتيب العناصر في القائمة عشوائيًا.\n\n💡 الاستخدامات: الألعاب، الاختبارات العشوائية، المحاكاة.",
      "code": "import random\nprint(random.randint(1, 5))  # رقم عشوائي من 1 لـ 5\nprint(random.random())        # رقم عشري بين 0 و 1\nprint(random.choice(['أحمد', 'منى', 'سارة']))  # اختيار اسم\n\nnums = [1, 2, 3, 4]\nrandom.shuffle(nums)\nprint(nums)",
      "output": "3\n0.7483948\nمنى\n[3, 1, 4, 2]",
      "notes": "- random موجودة ضمن مكتبة بايثون القياسية.\n- القيم العشوائية قد تختلف كل مرة تنفذ فيها الكود.\n- يمكنك ضبط البذرة العشوائية باستخدام random.seed() لنتائج متوقعة.",
      "question": {
        "type": "multiple",
        "text": "أي دالة تستخدم لاختيار عنصر عشوائي من قائمة؟",
        "options": [
          "random.choice()",
          "random.select()",
          "random.pick()",
          "random.shuffle()"
        ],
        "correct": "random.choice()",
        "explanation": "الدالة choice تختار عنصر واحد عشوائي من القائمة، بينما shuffle يخلط ترتيب العناصر."
      }
    },
    {
      "title": "استخدام string module",
      "subtitle": "التعامل مع النصوص والثوابت النصية الجاهزة",
      "explanation": "📌 الـ string module بيوفر ثوابت جاهزة ودوال مفيدة للتعامل مع النصوص.\n\nأشهر الثوابت:\n- `string.ascii_letters`: جميع الحروف الإنجليزية (كبيرة وصغيرة).\n- `string.ascii_lowercase`: الحروف الصغيرة فقط.\n- `string.ascii_uppercase`: الحروف الكبيرة فقط.\n- `string.digits`: الأرقام من 0 لـ 9.\n- `string.punctuation`: جميع علامات الترقيم.\n\n💡 الفائدة: مفيد في التحقق من البيانات، إنشاء كلمات مرور، أو توليد نصوص.",
      "code": "import string\nprint(string.ascii_letters)\nprint(string.digits)\nprint(string.punctuation)",
      "output": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n0123456789\n!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
      "notes": "- string لا تحتوي على دوال كثيرة، لكنها غنية بالثوابت.\n- تستخدم غالبًا مع عمليات الفحص والتحقق أو التوليد العشوائي مع random.",
      "question": {
        "type": "multiple",
        "text": "أي ثابت من string يحتوي على الحروف الكبيرة فقط؟",
        "options": [
          "string.ascii_letters",
          "string.ascii_lowercase",
          "string.ascii_uppercase",
          "string.uppercase_letters"
        ],
        "correct": "string.ascii_uppercase",
        "explanation": "ascii_uppercase يحتوي على الحروف الكبيرة فقط، بينما ascii_letters يحتوي على الكبيرة والصغيرة معًا."
      }
    },

    {
      "title": "مشروع تطبيقي: مولد كلمات المرور العشوائية",
      "subtitle": "تجميع القوائم وعملياتها مع random و string",
      "explanation": "📌 المشروع عبارة عن برنامج يقوم بإنشاء كلمات مرور قوية وعشوائية حسب إعدادات يحددها المستخدم.\n\nالمزايا:\n- يدمج بين استخدام القوائم List وعملياتها.\n- يستفيد من string module للحصول على الحروف والأرقام والرموز.\n- يستخدم random module لاختيار العناصر العشوائية.\n- يوضح استيراد Modules جاهزة في بايثون.\n\nخطوات العمل:\n1️⃣ المستخدم يدخل طول كلمة المرور.\n2️⃣ يحدد إذا كانت تحتوي على أرقام، حروف صغيرة، حروف كبيرة، وعلامات ترقيم.\n3️⃣ يتم تكوين قائمة بالعناصر المسموح بها.\n4️⃣ البرنامج يولد كلمة مرور عشوائية باستخدام الاختيار العشوائي.\n\n💡 هذا المشروع يربط بين أغلب المفاهيم السابقة في تطبيق عملي واحد.",
      "code": "import random\nimport string\n\n# --- 1. Enter password settings ---\nlength = int(input(\"Enter the desired password length: \"))\n\ninclude_digits = input(\"Include digits? (y/n): \").lower() == 'y'\ninclude_lower = input(\"Include lowercase letters? (y/n): \").lower() == 'y'\ninclude_upper = input(\"Include uppercase letters? (y/n): \").lower() == 'y'\ninclude_symbols = input(\"Include punctuation symbols? (y/n): \").lower() == 'y'\n\n# --- 2. Create a list of possible characters ---\nchars = ''\n\nif include_digits:\n    chars += string.digits\n\nif include_lower:\n    chars += string.ascii_lowercase\n\nif include_upper:\n    chars += string.ascii_uppercase\n\nif include_symbols:\n    chars += string.punctuation\n\n# --- 3. Check that the characters string is not empty ---\nif not chars:\n    print(\"⚠ You must select at least one type of characters!\")\nelse:\n    # --- 4. Generate the password without loops ---\n    password = ''.join(random.choices(chars, k=length))\n    print(f\"\\n🔐 Your random password: {password}\")",
      "output": "أدخل طول كلمة المرور المطلوبة: 8\nهل تريد إضافة أرقام؟ (y/n): y\nهل تريد إضافة حروف صغيرة؟ (y/n): y\nهل تريد إضافة حروف كبيرة؟ (y/n): y\nهل تريد إضافة علامات ترقيم؟ (y/n): n\n\n🔐 كلمة المرور العشوائية: A9c1k2bX",
      "notes": "- تم استخدام List لتجميع الحروف الممكنة.\n- استخدمنا extend() لإضافة عناصر متعددة.\n- random.choice() لاختيار عناصر عشوائية.\n- string module لتوفير مجموعات الحروف والأرقام والرموز.\n- التحقق من القائمة قبل الاستخدام يمنع حدوث أخطاء.",
      "question": {
        "type": "multiple",
        "text": "ما الدالة التي استخدمناها لاختيار عنصر عشوائي من القائمة؟",
        "options": [
          "random.choice()",
          "random.pick()",
          "random.shuffle()",
          "random.randint()"
        ],
        "correct": "random.choice()",
        "explanation": "random.choice() تختار عنصرًا واحدًا عشوائيًا من القائمة، وهي الأنسب هنا لإنشاء كلمة المرور."
      }
    }
  ],
  "lec5": [
    {
      "title": "Tuple (الصفوف الثابتة) في بايثون",
      "subtitle": "إمتى أستخدم بيانات ثابتة وليه مهمة",
      "explanation": "\nالـ Tuple هي نوع بيانات شبه الـ List لكن «ثابت» (immutable): بعد إنشائها مينفعش تغيّر عناصرها أو تضيف/تحذف منها. ده مفيد لما تكون عايز بيانات مضمونة ما تتبدلش بالغلط، زي: إحداثيات مكان، أيام الأسبوع، ثوابت الإعدادات.\n- بتدعم الفهرسة (indexing) والتقطيع (slicing) والتكرار (looping).\n- تقدر تعمل «تفكيك» (unpacking) بسهولة: x, y = (10, 20).\n- فرقها عن الـ List: الـ List متغيرة (mutable) ومناسبة للبيانات اللي بتتعدل كتير، أما الـ Tuple أخف وأأمن للثوابت.",
      "code": "\n# إنشاء Tuple\ncolors = (\"red\", \"green\", \"blue\")\nprint(colors[0])      # red\nprint(colors[-1])     # blue\nprint(colors[0:2])    # ('red', 'green')\n\n# تفكيك العناصر (Unpacking)\npoint = (10, 20)\nx, y = point\nprint(x, y)           # 10 20\n\n# محاولة تعديل عنصر (سيؤدي لخطأ)\n# colors[1] = \"yellow\"  # TypeError: 'tuple' object does not support item assignment\n\n# التحويل بين List و Tuple\nnums_list = [1, 2, 3]\nnums_tuple = tuple(nums_list)\nback_to_list = list(nums_tuple)\nprint(nums_tuple)     # (1, 2, 3)\n",
      "output": "\nred\nblue\n('red', 'green')\n10 20\n(1, 2, 3)",
      "notes": "\n- الأقواس ممكن تُحذف في بعض الحالات: a = 1, 2, 3 يعمل Tuple تلقائيًا.\n- لو عنصر واحد لازم فاصلة: single = (5,)\n- ينفع تحتوي أنواع مختلفة: (1, \"hi\", True)\n- لو جوّاها عنصر متغيّر (زي List)، تقدر تغيّر الليست نفسها لكن مش مرجعها.\n",
      "question": {
        "type": "multiple",
        "text": "أي سطر هيعمل خطأ؟",
        "options": [
          "x, y = (1, 2)",
          "user = (\"Ali\", 20); age = user[1]",
          "colors = (\"r\", \"g\"); colors[0] = \"y\"",
          "nums = tuple([1,2,3])"
        ],
        "correct": "colors = (\"r\", \"g\"); colors[0] = \"y\"",
        "explanation": "الـ Tuple غير قابلة للتعديل، فالمحاولة دي تعمل TypeError."
      }
    },
    {
      "title": "Nested List (قوائم داخل قوائم) + عمليات مهمة",
      "subtitle": "تمثيل الجداول والمصفوفات ببساطة",
      "explanation": "\nالـ Nested List هي List عناصرها Lists أخرى. ممتازة لتمثيل جداول/مصفوفات: صفوف وأعمدة.\n- الوصول: matrix[row][col]\n- التعديل: تغيّر قيمة عنصر معين بسهولة.\n- عمليات شائعة: حساب مجموع صف/عمود، تفريغ القائمة (flatten)، نسخ عميق لتجنب مشاكل المراجع.",
      "code": "\n# مصفوفة 3x3\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nprint(matrix[1][2])         # 6\nmatrix[1][1] = 50           # تعديل\nprint(matrix[1])            # [4, 50, 6]\n\n# مجموع كل صف  و كل الامثلة اللي جايه لسه هتفهموها لما تاخدوا موضوع التكرار\nrow_sums = [sum(row) for row in matrix]\nprint(row_sums)             # [6, 60, 24]\n\n# مجموع عمود (العمود 0)\ncol0_sum = sum(row[0] for row in matrix)\nprint(col0_sum)             # 1 + 4 + 7 = 12\n\n# تفريغ لقائمة واحدة\nflat = [item for row in matrix for item in row]\nprint(flat)                 # [1, 2, 3, 4, 50, 6, 7, 8, 9]\n\n# إنشاء مصفوفة آمنة من الأصفار 3x3\nsafe = [[0 for _ in range(3)] for _ in range(3)]\nsafe[0][0] = 99\nprint(safe)                 # الصف الأول فقط يتغيّر\n",
      "output": "\n6\n[4, 50, 6]\n[6, 60, 24]\n12\n[1, 2, 3, 4, 50, 6, 7, 8, 9]\n[[99, 0, 0], [0, 0, 0], [0, 0, 0]]",
      "notes": "\n- استخدم enumerate في الحلقات لو احتجت أرقام الصفوف/الأعمدة.\n- لتنسيق الطباعة كجدول: جرّب f-strings مع عرض ثابت لكل خانة.\n- لو عايز ثبات: خزن الصف كـ Tuple بدل List.\n",
      "question": {
        "type": "multiple",
        "text": "أنسب طريقة آمنة لإنشاء مصفوفة أصفار 4x4 بدون مشاركة مراجع الصفوف؟",
        "options": [
          "zeros = [[0]*4]*4",
          "zeros = [[0 for _ in range(4)] for _ in range(4)]",
          "zeros = [0]*16",
          "zeros = list([0,0,0,0])*4"
        ],
        "correct": "zeros = [[0 for _ in range(4)] for _ in range(4)]",
        "explanation": "الأولى بتشارك نفس المرجع بين الصفوف؛ الطريقة الصحيحة تولّد صفًا جديدًا كل مرة."
      }
    },
    {
      "title": "مشروع 1: الأرنب في الحديقة",
      "subtitle": "تحديث Nested List بناءً على إدخال المستخدم",
      "explanation": "\nالمشروع بيحاكي حديقة 3×3 كلها عشب 🌿.\nالمستخدم يختار الصف والعمود اللي عايز الأرنب 🐇 يروح لهم.\nالبرنامج بيحدث الـ Nested List ويحط الأرنب في المكان المطلوب، وبعدين يعرض الحديقة الجديدة.\nمفيش أي تكرار في الكود، الوصول والتغيير مباشر بالفهرسة.",
      "code": "\n# إنشاء الحديقة 3x3\ngarden = [\n    [\"🌿\", \"🌿\", \"🌿\"],\n    [\"🌿\", \"🌿\", \"🌿\"],\n    [\"🌿\", \"🌿\", \"🌿\"]\n]\n\nprint(\"\\n🐇: Please, I am hungry! Can you help me find food?\\n\")\n\n# عرض الحديقة الأولية\nprint(' '.join(garden[0]))\nprint(' '.join(garden[1]))\nprint(' '.join(garden[2]))\n\n# إدخال الموقع من المستخدم\nrow = int(input(\"\\nEnter row (1-3): \")) - 1\ncol = int(input(\"Enter column (1-3): \")) - 1\n\n# وضع الأرنب في المكان المطلوب\ngarden[row][col] = \"🐇\"\n\n# عرض الحديقة بعد التحديث\nprint()\nprint(' '.join(garden[0]))\nprint(' '.join(garden[1]))\nprint(' '.join(garden[2]))\n\nprint(\"\\n🐇: Thanks for the food! ❤️\")",
      "output": "\nExample:\n🐇: Please, I am hungry! Can you help me find food?\n\n🌿 🌿 🌿\n🌿 🌿 🌿\n🌿 🌿 🌿\n\nEnter row (1-3): 2\nEnter column (1-3): 3\n\n🌿 🌿 🌿\n🌿 🌿 🐇\n🌿 🌿 🌿\n\n🐇: Thanks for the food! ❤️",
      "notes": "\n- [row][col] بيوصل لمكان محدد في الـ Nested List.\n- ناقص 1 لأن المستخدم بيبدأ العد من 1، لكن الفهارس في بايثون من 0.\n- join() بيخلي عرض الصفوف أنيق بدل ما يطلع الأقواس والفواصل.",
      "question": {
        "type": "multiple",
        "text": "لو المستخدم دخل row=1 و col=2، فين هيكون الأرنب؟",
        "options": [
          "في الصف الأول العمود الثاني",
          "في الصف الثاني العمود الأول",
          "في الصف الثاني العمود الثاني",
          "في الصف الأول العمود الأول"
        ],
        "correct": "في الصف الأول العمود الثاني",
        "explanation": "الفهارس تبدأ من 0، لكن الإدخال هنا بنقص منه 1، فـ row=1 → index 0، وcol=2 → index 1."
      }
    },
    {
      "title": "مشروع 2 : لعبة حجر-ورقة-مقص",
      "subtitle": "تحدي بسيط بين المستخدم والكمبيوتر",
      "explanation": "\nاللعبة الشهيرة حجر 🪨، ورقة 📄، مقص ✂️.\nالمستخدم يختار أحد الثلاثة، والكمبيوتر يختار عشوائيًا.\nالبرنامج يحدد الفائز بناءً على القواعد:\n- الحجر يكسر المقص.\n- المقص يقطع الورقة.\n- الورقة تغطي الحجر.\nمفيش أي تكرار في الكود، والاختيار العشوائي بيتم باستخدام مكتبة random.",
      "code": "#انت دلوقتي تقدر تعملها بنفسك",
      "output": "....",
      "notes": "\n- random.choice() بيختار عنصر عشوائي من tuple أو list.\n- كل الشروط مكتوبة بدون تكرار للحلقات.\n- ممكن تستخدم tuple بدل list لأن الاختيارات ثابتة.",
      "question": {
        "type": "multiple",
        "text": "لو المستخدم اختار paper والكمبيوتر اختار rock، مين الفائز؟",
        "options": ["المستخدم", "الكمبيوتر", "تعادل", "مفيش فائز"],
        "correct": "المستخدم",
        "explanation": "الورقة تغطي الحجر، فالمستخدم هو الفائز."
      }
    }
  ],
  "lec6": [
    {
      "title": "range() (النطاق العددي)",
      "subtitle": "توليد أرقام بطريقة ذكية وموفرة للذاكرة",
      "explanation": "📌 **الغرض والهدف**:\nالدالة `range` بتساعدك تولّد أرقام أوتوماتيكيًا بدل ما تكتبهم واحد واحد. مفيدة جدًا لو بتعد أو بتكرر عملية في الكود.\n\n📖 **شرح تفصيلي**:\n- `range` بتعمل تسلسل من الأرقام حسب القيم اللي تحددها.\n- لها 3 قيم ممكن تدخلهم:\n  1. **start**: الرقم اللي هتبدأ منه (لو ما كتبتهوش، هيبدأ من 0).\n  2. **stop**: الرقم اللي هتوقف عنده (غير شامل).\n  3. **step**: الفرق بين كل رقم والتاني (افتراضي = 1، وممكن يكون سالب للعد التنازلي).\n- أمثلة:\n  - `range(5)` → 0, 1, 2, 3, 4\n  - `range(2, 6)` → 2, 3, 4, 5\n  - `range(10, 0, -2)` → 10, 8, 6, 4, 2\n",
      "code": "print(list(range(5)))            # [0, 1, 2, 3, 4]\nprint(list(range(2, 7)))         # [2, 3, 4, 5, 6]\nprint(list(range(10, 0, -2)))    # [10, 8, 6, 4, 2]",
      "output": "[0, 1, 2, 3, 4]\n[2, 3, 4, 5, 6]\n[10, 8, 6, 4, 2]",
      "notes": "- stop غير شامل.\n- مفيد للتكرار N مرة.\n- يوفر ذاكرة لأنه ما بيخزنش كل القيم مرة واحدة.",
      "question": {
        "type": "multiple",
        "text": "ما نتيجة list(range(5, -1, -2)) ؟",
        "options": [
          "[5, 4, 3, 2, 1, 0]",
          "[5, 3, 1, -1]",
          "[5, 3, 1]",
          "[5, 2, -1]"
        ],
        "correct": "[5, 3, 1]",
        "explanation": "stop غير شامل، فالنتيجة 5, 3, 1 وتتوقف قبل -1."
      }
    },
    {
      "title": "حلقة for",
      "subtitle": "التكرار بسهولة على أي تسلسل",
      "explanation": "📌 **الغرض والهدف**:\nالـ loops في البرمجة بتسمح لك تكرر نفس الكود أكتر من مرة بدل ما تكتبه يدويًا لكل حالة، وده بيوفر وقت ويمنع التكرار. فيه أنواع مختلفة من الحلقات، منها for و while.\n\n📖 **شرح حلقة for**:\nحَلقة `for` بتسمح لك تكرر كود معين على كل عنصر في تسلسل (زي list أو string أو range). بتشتغل إنها تقرأ عنصر تلو الآخر من أي Iterable، وتنفذ عليه الكود.\n- مناسبة جدًا لما تكون عارف عدد العناصر أو بتمر على بيانات ثابتة.\n- مثال: لو عندك قائمة أسماء، تقدر تستخدم `for` لعرض كل اسم بدون ما تكتب الكود لكل اسم يدوي.\n\n💡 **مثال من الحياة**:\nزي المدرس اللي بينادي أسماء الطلاب واحد واحد من كشف الحضور وينفذ نفس الإجراء (يقول حاضر أو غائب) على كل اسم.",
      "code": "# المرور على قائمة أسماء\nnames = ['Ali', 'Sara', 'Omar']\nfor name in names:\n    print('Hello', name)\n\n# التكرار باستخدام range\nfor i in range(1, 6):\n    print(i)\n\n",
      "output": "Hello Ali\nHello Sara\nHello Omar\n1\n2\n3\n4\n5\n",
      "notes": "- استخدم enumerate لو عايز الفهرس مع القيمة.\n- range ممتاز للتكرار بعدد مرات محدد.",
      "question": {
        "type": "multiple",
        "text": "لو عملت for i in range(3): على قائمة فيها 3 عناصر، كام مرة الكود هيتنفذ؟",
        "options": ["مرة واحدة", "3 مرات", "4 مرات", "عدد لا نهائي"],
        "correct": "3 مرات",
        "explanation": "range(3) بيدي القيم 0 و 1 و 2، يعني 3 تكرارات."
      }
    },
    {
      "title": "Nested Loop (حلقة داخل حلقة)",
      "subtitle": "تكرار متعدد المستويات",
      "explanation": "📌 **الغرض والهدف**:\nالـ loops بشكل عام بتكرر نفس الكود على مجموعة عناصر، لكن الـ Nested Loop معناها إنك تحط حلقة داخل حلقة، بحيث تتكرر الحلقة الداخلية بالكامل لكل دورة من الحلقة الخارجية. ده مفيد جدًا لو بتتعامل مع بيانات متعددة الأبعاد أو جداول.\n\n📖 **شرح الـ Nested Loop**:\n- الحلقة الخارجية تتحكم في عدد مرات تشغيل الحلقة الداخلية.\n- الحلقة الداخلية تنفذ بالكامل في كل مرة تدور فيها الحلقة الخارجية.\n- تُستخدم كثيرًا مع القوائم المتداخلة (Nested Lists) أو عند المرور على صفوف وأعمدة.\n\n💡 **مثال من الحياة**:\nزي المدرس اللي عنده أكثر من فصل، ولكل فصل مجموعة طلاب. المدرس يمر على كل فصل (الحلقة الخارجية)، وداخل كل فصل ينادي أسماء الطلاب (الحلقة الداخلية).",
      "code": "for i in range(1, 4):\n    for j in range(1, 4):\n        print(f\"{i} x {j} = {i * j}\")",
      "output": "1 x 1 = 1\n 1 x 2 = 2\n 1 x 3 = 3\n 2 x 1 = 2\n 2 x 2 = 4\n 2 x 3 = 6\n 3 x 1 = 3\n 3 x 2 = 6\n 3 x 3 = 9",
      "notes": "- الحلقة الداخلية تنفذ بالكامل لكل دورة من الحلقة الخارجية.\n- مفيدة للتعامل مع البيانات على شكل جداول أو مصفوفات.\n- عدد التكرارات الكلي = تكرارات الحلقة الخارجية × تكرارات الحلقة الداخلية.",
      "question": {
        "type": "multiple",
        "text": "كم مرة سيطبع الكود التالي؟\n\nfor x in range(2):\n    for y in range(3):\n        print(x, y)",
        "options": ["2", "3", "5", "6"],
        "correct": "6",
        "explanation": "الحلقة الخارجية تتكرر 2 مرة، وكل مرة تتكرر الداخلية 3 مرات، إذن المجموع = 2 × 3 = 6."
      }
    },
    {
      "title": "حلقة while",
      "subtitle": "التكرار بناءً على شرط",
      "explanation": "📌 الغرض والهدف: while بتستخدم لتكرار كود طالما شرط معين صحيح.\n\n📖 شرح تفصيلي: حلقة while بتبدأ بتنفيذ الكود وتفضل تعيد تنفيذه طول ما الشرط بيساوي True. لازم تتأكد إن الشرط هيتغير في يوم من الأيام علشان ما تدخلش في حلقة لا نهائية.\n\n💡 مثال من الحياة: زي ما انت بتفضل تمشي في الشارع طالما لسه ماوصلتش بيتك، لكن أول ما توصل، بتوقف.",
      "code": "count = 1\nwhile count <= 5:\n    print(count)\n    count += 1",
      "output": "1\n2\n3\n4\n5",
      "notes": "- لازم تحديث المتغير داخل الحلقة.\n- خطر الحلقة اللانهائية لو الشرط ما اتغيرش.",
      "question": {
        "type": "multiple",
        "text": "إيه اللي ممكن يحصل لو نسيت تعدّل المتغير داخل while؟",
        "options": [
          "الحلقة هتشتغل مرة واحدة",
          "هتشتغل عدد محدود من المرات",
          "هتشتغل للأبد",
          "هتطلع خطأ SyntaxError"
        ],
        "correct": "هتشتغل للأبد",
        "explanation": "لأن الشرط هيفضل True طول الوقت."
      }
    },
    {
      "title": "break و continue",
      "subtitle": "التحكم في تدفق الحلقات",
      "explanation": "📌 الغرض والهدف: break و continue أدوات للتحكم في الحلقات.\n\n📖 شرح تفصيلي:\n- break: توقف الحلقة فورًا حتى لو لسه باقي عناصر.\n- continue: تتخطى باقي الكود في الدورة الحالية وتروح للدورة اللي بعدها.\n\n💡 مثال من الحياة: زي ما تكون في اجتماع، وقررت تمشي فجأة (break)، أو تتجاهل موضوع معين وتكمل باقي الاجتماع (continue).",
      "code": "for i in range(1, 6):\n    if i == 3:\n        break\n    print(i)\n\nfor i in range(1, 6):\n    if i == 3:\n        continue\n    print(i)",
      "output": "1\n2\n1\n2\n4\n5",
      "notes": "- break يخرج من الحلقة تمامًا.\n- continue يكمل لكن يتخطى الباقي في الدورة الحالية.",
      "question": {
        "type": "multiple",
        "text": "في الحلقة الأولى، إيه آخر رقم اتطبع قبل ما توقف؟",
        "options": ["2", "3", "4", "5"],
        "correct": "2",
        "explanation": "لأن عند i = 3 حصل break وخرجنا."
      }
    },
    {
      "title": "Slicing (التقطيع)",
      "subtitle": "أخذ جزء من قائمة أو نص",
      "explanation": "📌 الغرض والهدف: slicing بيخليك تاخد جزء من list أو string أو أي تسلسل بسهولة.\n\n📖 شرح تفصيلي: الصيغة هي seq[start:stop:step]، حيث start البداية، stop النهاية (غير شاملة)، step الخطوة. أي قيمة ممكن تسيبها فاضية وتاخد الافتراضي.\n\n💡 مثال من الحياة: زي لما تاخد شريحة من كيكه بدل الكيكه كلها.",
      "code": "nums = [0, 1, 2, 3, 4, 5]\nprint(nums[1:4])      # [1, 2, 3]\nprint(nums[:3])       # [0, 1, 2]\nprint(nums[::2])      # [0, 2, 4]\ntext = \"Hello World\"\nprint(text[6:])       # World",
      "output": "[1, 2, 3]\n[0, 1, 2]\n[0, 2, 4]\nWorld",
      "notes": "- step ممكن يكون سالب للاتجاه العكسي.\n- start أو stop ممكن يتسابوا فاضيين.",
      "question": {
        "type": "multiple",
        "text": "لو nums = [10, 20, 30, 40, 50]، إيه نتيجة nums[1:4]؟",
        "options": [
          "[10, 20, 30]",
          "[20, 30, 40]",
          "[20, 30, 40, 50]",
          "[30, 40]"
        ],
        "correct": "[20, 30, 40]",
        "explanation": "start = index 1، stop = index 4 (غير شامل)."
      }
    },
    {
      "title": "مشروع تطبيقي: برنامج إدارة المهام",
      "subtitle": "تطبيق عملي يجمع الحلقات والقوائم والشروط",
      "explanation": "📌 **الغرض والهدف**: إنشاء برنامج بسيط لإدارة المهام اليومية، بحيث نقدر نضيف مهام، نعرض القائمة، نحذف مهمة، أو نبحث عن مهمة.\n\n📖 **شرح تفصيلي**: البرنامج بيستخدم قائمة لتخزين المهام، وحلقة تكرارية للتفاعل المستمر مع المستخدم لحد ما يختار الخروج. يتم استخدام الشروط للتحقق من اختيارات المستخدم، وbreak لإنهاء البرنامج.\n\n💡 **مثال من الحياة**: زي تطبيق To-Do List على الموبايل اللي بيخليك تسجل وتدير مهامك.",
      "code": "tasks = []\n\nwhile True:\n    print(\"\\n=== برنامج إدارة المهام ===\")\n    print(\"1. عرض المهام\")\n    print(\"2. إضافة مهمة\")\n    print(\"3. حذف مهمة\")\n    print(\"4. البحث عن مهمة\")\n    print(\"5. خروج\")\n\n    choice = input(\"اختر رقم العملية: \")\n\n    if choice == '1':\n        if not tasks:\n            print(\"📭 لا توجد مهام\")\n        else:\n            for i, task in enumerate(tasks, start=1):\n                print(f\"{i}. {task}\")\n\n    elif choice == '2':\n        new_task = input(\"أدخل المهمة الجديدة: \")\n        tasks.append(new_task)\n        print(\"✅ تم إضافة المهمة\")\n\n    elif choice == '3':\n        del_index = int(input(\"أدخل رقم المهمة التي تريد حذفها: \")) - 1\n        if 0 <= del_index < len(tasks):\n            removed = tasks.pop(del_index)\n            print(f\"🗑️ تم حذف المهمة: {removed}\")\n        else:\n            print(\"❌ رقم غير صحيح\")\n\n    elif choice == '4':\n        search = input(\"أدخل اسم المهمة للبحث: \")\n        found = False\n        for task in tasks:\n            if search.lower() in task.lower():\n                print(f\"🔍 تم العثور على المهمة: {task}\")\n                found = True\n                break\n        if not found:\n            print(\"🚫 لم يتم العثور على المهمة\")\n\n    elif choice == '5':\n        print(\"👋 تم الخروج من البرنامج\")\n        break\n\n    else:\n        print(\"⚠️ اختيار غير صحيح، حاول مرة أخرى\")",
      "output": "=== برنامج إدارة المهام ===\n1. عرض المهام\n2. إضافة مهمة\n3. حذف مهمة\n4. البحث عن مهمة\n5. خروج\nاختر رقم العملية: 2\nأدخل المهمة الجديدة: مذاكرة بايثون\n✅ تم إضافة المهمة\n=== برنامج إدارة المهام ===\n1. عرض المهام\n...\nاختر رقم العملية: 1\n1. مذاكرة بايثون",
      "notes": "- المشروع بيجمع: while loop + for loop + if/else + break + enumerate + القوائم.\n- تقدر تطوره بحيث يحفظ البيانات في ملف خارجي."
    }
  ],
  "lec7": [
    {
      "title": "تعريف الفانكشن",
      "subtitle": "ما هي الفانكشن ولماذا نستخدمها؟",
      "explanation": "📌 الغرض والهدف: الفانكشن هي مجموعة أوامر مجمعة في كتلة واحدة يمكن استدعاؤها عدة مرات بدل تكرار نفس الكود.\n\n📖 شرح تفصيلي: الفانكشن تساعد على تنظيم الكود وتقليل التكرار وتسهيل التعديل. كل فانكشن لها اسم يمكن من خلاله استدعاؤها.\n\n💡 مثال من الحياة: زي ما يكون عندك وصفة طبخ محفوظة، كل مرة عايز تعمل الأكلة دي، تتبع نفس الوصفة بدل ما تفكر في الخطوات من جديد.",
      "code": "def say_hello():\n    print(\"Hello!\")\n\nsay_hello()",
      "output": "Hello!",
      "notes": "- الفانكشن بتتعرف مرة واحدة ويمكن استدعاؤها عدة مرات.\n- لازم تبدأ باسم واضح ومعبر.",
      "question": {
        "type": "multiple",
        "text": "إيه فائدة استخدام الفانكشن؟",
        "options": [
          "تنظيم الكود وتقليل التكرار",
          "جعل البرنامج أبطأ",
          "زيادة عدد الأسطر",
          "استبدال الحلقات"
        ],
        "correct": "تنظيم الكود وتقليل التكرار",
        "explanation": "الفانكشن بتجمع الأوامر في مكان واحد بحيث يسهل استخدامها وصيانتها."
      }
    },
    {
      "title": "إنشاء الفانكشن",
      "subtitle": "Syntax وتعريف الدوال",
      "explanation": "📌 الغرض والهدف: نعرف الصيغة الصحيحة لإنشاء فانكشن.\n\n📖 شرح تفصيلي: إنشاء فانكشن بيكون باستخدام الكلمة def ثم اسم الفانكشن، وبعدين أقواس ممكن تحتوي على باراميترز، وبعدها نقطتين، والكود يكون بداخل البلوك.\n\n💡 مثال من الحياة: زي ما تكتب عنوان لوصفة جديدة في كراسة الطبخ، بعدها خطوات التحضير تحتها.",
      "code": "def greet():\n    print(\"Welcome!\")\n\ngreet()",
      "output": "Welcome!",
      "notes": "- اسم الفانكشن لازم يكون معبر ومكون من حروف وأرقام وUnderscore.\n- الأقواس ممكن تبقى فاضية لو مفيش مدخلات.",
      "question": {
        "type": "multiple",
        "text": "إيه الكلمة المفتاحية اللي بنستخدمها لتعريف فانكشن في بايثون؟",
        "options": ["function", "def", "func", "define"],
        "correct": "def",
        "explanation": "في بايثون بنستخدم الكلمة المفتاحية def علشان نعرف فانكشن."
      }
    },
    {
      "title": "استدعاء الفانكشن",
      "subtitle": "تشغيل الكود داخل الدالة",
      "explanation": "📌 الغرض والهدف: معرفة كيفية تنفيذ الفانكشن بعد تعريفها.\n\n📖 شرح تفصيلي: بعد تعريف الفانكشن، لازم نستدعيها باستخدام اسمها متبوعًا بأقواس، لو فيه باراميترز لازم نمرر قيم ليهم.\n\n💡 مثال من الحياة: زي ما تدوس على زر في ماكينة، لازم تضغط علشان تبدأ تشتغل.",
      "code": "def say_hi():\n    print(\"Hi there!\")\n\nsay_hi()",
      "output": "Hi there!",
      "notes": "- الأقواس مهمة حتى لو الفانكشن مفيهاش باراميترز.\n- ممكن نستدعي نفس الفانكشن أكتر من مرة.",
      "question": {
        "type": "multiple",
        "text": "إيه اللي هيحصل لو ما استدعيتش الفانكشن؟",
        "options": [
          "هتشتغل تلقائي",
          "مش هتشتغل خالص",
          "هترجع None تلقائي",
          "هتطبع Error"
        ],
        "correct": "مش هتشتغل خالص",
        "explanation": "الفانكشن مش بتشتغل إلا لما تستدعيها."
      }
    },
    {
      "title": "الباراميترز والآرجومنتس",
      "subtitle": "تمرير البيانات للفانكشن",
      "explanation": "📌 الغرض والهدف: الباراميترز بتسمح للفانكشن إنها تستقبل قيم خارجية وقت الاستدعاء.\n\n📖 شرح تفصيلي: الباراميتر بيتكتب في تعريف الفانكشن وهو المتغير اللي بيستقبل القيمة، أما الآرجومنت فهي القيمة اللي بتمررها عند الاستدعاء.\n\n💡 مثال من الحياة: زي ما تطلب مشروب من كافيه وتحدد النوع، النوع ده هو الآرجومنت، والنادل بيستقبل الطلب كأنه باراميتر.",
      "code": "def greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Sara\")",
      "output": "Hello, Sara!",
      "notes": "- ممكن يكون فيه أكتر من باراميتر.\n- ممكن تحدد قيم افتراضية للباراميتر.",
      "question": {
        "type": "multiple",
        "text": "إيه الفرق بين الباراميتر والآرجومنت؟",
        "options": [
          "مفيش فرق بينهم",
          "الباراميتر بيكون في تعريف الفانكشن والآرجومنت بيكون في الاستدعاء",
          "الآرجومنت بيكون في تعريف الفانكشن والباراميتر في الاستدعاء",
          "الباراميتر بيكون قيمة ثابتة والآرجومنت قيمة متغيرة"
        ],
        "correct": "الباراميتر بيكون في تعريف الفانكشن والآرجومنت بيكون في الاستدعاء",
        "explanation": "الباراميتر متغير بيستقبل قيمة، الآرجومنت هي القيمة اللي بتمررها للفانكشن."
      }
    },
    {
      "title": "return",
      "subtitle": "إرجاع القيم من الدوال",
      "explanation": "📌 الغرض والهدف: return بتستخدم علشان ترجع نتيجة من الفانكشن علشان تقدر تستخدمها في مكان تاني في الكود.\n\n📖 شرح تفصيلي: بمجرد تنفيذ return، الفانكشن بتتوقف عن العمل وبترجع القيمة اللي حددتها. لو ما استخدمتش return، الفانكشن هترجع None بشكل افتراضي.\n\n💡 مثال من الحياة: زي لما تسأل حد على عنوان، هو بيرجعلك العنوان نفسه مش بيوديك للمكان.",
      "code": "def add(a, b):\n    return a + b\n\nresult = add(3, 5)\nprint(result)",
      "output": "8",
      "notes": "- بعد return الكود اللي بعده في نفس الفانكشن مش هيتنفذ.\n- ممكن ترجع أكتر من قيمة كمجموعة (tuple).",
      "question": {
        "type": "multiple",
        "text": "إيه اللي بيحصل لو الفانكشن مفيهاش return؟",
        "options": [
          "هترجع 0",
          "هترجع None",
          "هترجع قيمة فارغة",
          "هترجع آخر متغير اتعرف"
        ],
        "correct": "هترجع None",
        "explanation": "لو مفيش return، القيمة الافتراضية اللي بترجعها الفانكشن في بايثون هي None."
      }
    },
    {
      "title": "Scope",
      "subtitle": "نطاق المتغيرات في الفانكشن",
      "explanation": "📌 الغرض والهدف: معرفة الفرق بين المتغيرات المحلية والعالمية.\n\n📖 شرح تفصيلي: المتغير المحلي بيكون معرف داخل الفانكشن ومش متاح خارجها، بينما المتغير العالمي بيكون معرف خارج الفانكشن ومتاح في أي مكان.\n\n💡 مثال من الحياة: زي أدواتك الشخصية في البيت (محلية) مقابل الأدوات اللي في الشارع (عامة).",
      "code": "x = 10  # متغير عالمي\n\ndef show():\n    y = 5  # متغير محلي\n    print(x)\n    print(y)\n\nshow()\n# print(y)  # هتعمل Error",
      "output": "10\n5",
      "notes": "- المحلي بيتعرف ويستخدم داخل الفانكشن بس.\n- العالمي ممكن يتغير داخل الفانكشن باستخدام الكلمة global.",
      "question": {
        "type": "multiple",
        "text": "إيه اللي بيحصل لو حاولت تطبع متغير محلي خارج الفانكشن؟",
        "options": ["هيطبع القيمة", "هيرجع None", "هيطلع Error", "هيطبع 0"],
        "correct": "هيطلع Error",
        "explanation": "المتغير المحلي غير متاح خارج الفانكشن."
      }
    },
    {
      "title": "أنواع الفانكشن",
      "subtitle": "أنماط كتابة الدوال",
      "explanation": "📌 الغرض والهدف: التعرف على طرق مختلفة لتعريف الفانكشن.\n\n📖 شرح تفصيلي: في بايثون فيه فانكشن عادية، وفانكشن مجهولة الاسم (lambda functions)، وفانكشن بتاخد أو بترجع فانكشن تانية (higher-order functions).\n\n💡 مثال من الحياة: زي وصفة مكتوبة باسم، أو وصفة مكتوبة بسرعة على ورقة صغيرة بدون اسم، أو وصفة تستخدم وصفات تانية.",
      "code": "# فانكشن عادية\ndef square(x):\n    return x ** 2\n\n# فانكشن lambda\ncube = lambda x: x ** 3\n\nprint(square(4))\nprint(cube(3))",
      "output": "16\n27",
      "notes": "- lambda مفيدة للفانكشن الصغيرة.\n- higher-order functions بتتعامل مع فانكشن كقيم.",
      "question": {
        "type": "multiple",
        "text": "إيه ميزة lambda function؟",
        "options": [
          "أسرع في التنفيذ دائمًا",
          "صغيرة وممكن كتابتها في سطر واحد",
          "لا تحتاج أقواس",
          "بتشتغل بدون بايثون"
        ],
        "correct": "صغيرة وممكن كتابتها في سطر واحد",
        "explanation": "lambda بتستخدم للتعريف السريع لفانكشن صغيرة."
      }
    },
    {
      "title": "أفضل الممارسات",
      "subtitle": "كتابة دوال فعالة ونظيفة",
      "explanation": "📌 الغرض والهدف: كتابة فانكشن سهلة القراءة والصيانة.\n\n📖 شرح تفصيلي: خليك حريص إن الفانكشن تعمل حاجة واحدة بوضوح، واسمها يعبر عن وظيفتها، ومتكونش طويلة أو معقدة.\n\n💡 مثال من الحياة: زي كتابة تعليمات واضحة لشخص، بدل ما تكتب خطوات كتير ملخبطة.",
      "code": "def calculate_area(width, height):\n    return width * height\n\nprint(calculate_area(4, 5))",
      "output": "20",
      "notes": "- خلي الفانكشن قصيرة قدر الإمكان.\n- استخدم أسماء وصفية.\n- قلل الاعتماد على المتغيرات العالمية.",
      "question": {
        "type": "multiple",
        "text": "ليه بنفضل إن الفانكشن تعمل حاجة واحدة بس؟",
        "options": [
          "علشان تكون أسرع",
          "علشان تكون أسهل في الفهم والصيانة",
          "علشان الكود يكون أطول",
          "علشان تستهلك ذاكرة أقل"
        ],
        "correct": "علشان تكون أسهل في الفهم والصيانة",
        "explanation": "الفانكشن الواضحة والبسيطة بتكون أسهل في القراءة والتعديل."
      }
    }
  ]
}
